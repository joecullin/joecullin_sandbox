input {
    tcp {
        port => 5000
    }
}

filter {
    # Use [@metadata][xxx] for temp fields so they're not included in output, e.g. ymd.

    # specify which parser to use, by un-commenting one of these:
    kv {
        # default_keys => ["[@metadata][options][parser]", "dissect1"]
        default_keys => ["[@metadata][options][parser]", "grok1"]
    }

    # Test with invalid inputs
    #   echo "2020-02-1913:24:05 hello joe" | nc -v localhost 5000
    # --> conditional output if expected fields aren't good?
    #     https://www.elastic.co/guide/en/logstash/current/config-examples.html has an example of that.

    if [@metadata][options][parser] == "dissect1" {
        dissect {
          mapping => {
            "message" => "%{[@metadata][ymd]}-%{+[@metadata][ymd]}-%{+[@metadata][ymd]} %{hour}:%{minute}:%{second} %{message_text}"
          }
        }
    }
    else if [@metadata][options][parser] == "grok1" {
        grok {
            match => { "message" => "%{TIMESTAMP_ISO8601:[@metadata][timestamp]}\s(?<message_text>.*)" }
        }
        # This is redundant: it's the same components as TIMESTAMP_ISO8601.
        # But I haven't found a way to get the sub-pattern matches directly from the previous grok.
        grok {
            match => { "[@metadata][timestamp]" => "(?<[@metadata][ymd]>%{YEAR}-%{MONTHNUM}-%{MONTHDAY})[T ]%{HOUR:hour}:?%{MINUTE:minute}(?::?%{SECOND:second})?%{ISO8601_TIMEZONE}?" }
        }
    }

    # Put it all together into a nice one-line summary
    if "_grokparsefailure" in [tags] or "_dateparsefailure" in [tags] {
        mutate {
            add_field => {
                "summary" => "Parsing Error!!!"
            }
        }
    }
    else {
        mutate {
            add_field => {
                "summary" => "On %{[@metadata][ymd]} (at hour=%{hour}, minute=%{minute}, second=%{second}) we got this message: '%{message_text}' (parser=%{[@metadata][options][parser]})"
            }
        }
    }

    # Use this date as our timestamp.
    mutate {
        # Re-assemble into one field.
        add_field => {
            "[@metadata][date_time]" => "%{[@metadata][ymd]}T%{hour}:%{minute}:%{second}Z"
        }
    }
    date {
        match => [ "[@metadata][date_time]", "ISO8601" ]
    }

}

output {
    elasticsearch {
        hosts => "elasticsearch:9200"
        user => "elastic"
        password => "changeme"
    }
    stdout {
        id => "stdout_rubydebug"
        codec => rubydebug
    }
    stdout {
        id => "stdout_json"
        codec => json
    }
}
